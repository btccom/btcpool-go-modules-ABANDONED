package main

import (
	"encoding/hex"
	"merkle-tree-and-bitcoin/hash"
	"testing"
)

// 测试 BitsToTarget
func TestParseAuxPowData(t *testing.T) {
	// block-hash 为 big-endian
	{
		auxPowDataHex := "02000000010000000000000000000000000000000000000000000000000000000000000000ffffffff6303ae3313040d20575a726567696f6e312f50726f6a65637420425443506f6f6c2f20202020202020202020fabe6d6d68ad61d3e33851b9a68cf188036b5e9fa4369dfea8d6a914632df5f77a356875737265693120202001000006000000012e860000ffffffff0297799a09000000001976a914c0174e89bd93eacd1d5a1af4ba1802d412afc08688ac0000000000000000266a24aa21a9ed4da4992830437b84b45f652ff1023484f656be1161673f266ace43e5542362d5000000000000000000005731252ff669b3fcc644c37e50651eeb0e6e32e14a37814ba42907033fa7bc0751dde737fff3a90818c49d1e111c76f002e28c5c61497fdafed663333dd22cea0d2d73ed731d97b4377b756fed6f21d9397416d281b14080f3b95bdb0a8b3d2b47cd165e7e0ebaa19d7d3382fb6c8f24e9f2bc40e4e820b13c6b99fc8f92ffb57371d96082b06fc50783a7b4d5b793d52f2d4ebf919cc19ba55dc9a9f3202a75c3073b23048919132c8edf7461664f54601a8c20b8b05c121587da1e5c5aeda09b803b0c7fe8db388e45b7c3f6f3cbd1278a17746dfd2efbfa05671b85f8d3b02c56950f122c254049c5d58a73033f0966f3ca8dded25dc6241ccd00000000000000000002000020198575f8992ed09c15514add9a07c8c42c51b0e5c9097e562a03000000000000582064d99b09ceb79d8929d9850bfbe8465c3e6be23489a2b62509eb94b54fd00d20575a2548081ae9c57d8f"
		auxPowData, err := ParseAuxPowData(auxPowDataHex)
		if err != nil {
			t.Fatal(err)
		}

		hex := auxPowData.ToHex()
		if hex != auxPowDataHex {
			t.Errorf("Original and generated auxPowData are not equal.\nOriginal: %s\nGenerated: %s", auxPowDataHex, hex)
		}
	}

	// block-hash 为 little-endian
	{
		auxPowDataHex := "02000000010000000000000000000000000000000000000000000000000000000000000000ffffffff5802cb00049ead975a726567696f6e312f50726f6a65637420425443506f6f6c2ffabe6d6d2fc1edd5330b035c704c681c9ef725aab02367799ac9fdbb39f3f7a1ce79fbc501000000000000000100000bbb14000000000000ffffffff03a80a0395000000001976a914c0174e89bd93eacd1d5a1af4ba1802d412afc08688ac0000000000000000266a24aa21a9ed51e036bfe6cdd4151ac2f2e1ed67698398616c25c89fb66bc3336b57a856d80300000000000000002952534b424c4f434b3a3dc5cd0888920a53599fe450907e7d0a99d22b367c800f03ca98c4ed943858b5000000007d5958e62ad38a781e46c7511ef1862a71d811726e7db88e930193000000000001db1f8ff020364c2667343345e914727b3513dd036a6ce35b2c32ae35de42536700000000000000000002000020dba9acdfa05b3ad913703d24b0ca2363f8027cc0dfa19bad9e3c5669180c7a081a17db5c087fd47854733173edd04f8b3e722d3b5e27477c54501a52e91962099ead975affff7f20681b8aa1"
		auxPowData, err := ParseAuxPowData(auxPowDataHex)
		if err != nil {
			t.Fatal(err)
		}

		hex := auxPowData.ToHex()
		if hex != auxPowDataHex {
			t.Errorf("Original and generated auxPowData are not equal.\nOriginal: %s\nGenerated: %s", auxPowDataHex, hex)
		}
	}
}

func TestCheckAuxBranch(t *testing.T) {
	auxHashHex := "1743a6587e9be00550f89be9b8173255cfef414e853da0f6080265fac3eb4e83"
	auxPowHex := "02000000010000000000000000000000000000000000000000000000000000000000000000ffffffff5802d8010455b39c5a726567696f6e312f50726f6a65637420425443506f6f6c2ffabe6d6dd61c6af278fbd938a1b192a9f19acff03cf2f9d310a4d37930751cd50ee37842100000008df9e4830100000f0c3b020000000000ffffffff03d8595726000000001976a914c0174e89bd93eacd1d5a1af4ba1802d412afc08688ac0000000000000000266a24aa21a9ede33448ccd4936f87c2a94cc2972e2d2dd630686f371d43e12a79b82255300b7800000000000000002952534b424c4f434b3aa1e9d4f58d542ec62358c6eba342778341ab5069f6201dd5a94e238f22328d720000000000000000007ca5168e1657c92ee743e3c6f169420c99c5c2ee38d35edb133e610c015c09c8a8688a55d87cd895d485de25ea494f9b95c91034ac484c68f7901155db079d2f0b1a75b0845257e4fd04a513da19e1f880d58863aeb089179e723c1bcbbb7ab2de057f5034d955be29448b1402aaf41a6133684408e1808f3009a32bdcddf06787f6cd854e5f0ae876f08338ac160f7eb7c73e378b557c7db2e68b84a10fbc7bc1bb4e6d10e696e2247aa817cc785988162784c8009b54e464be562bf64de845c240155089c7cdcd7b58fa35c65411d3f2d7ad694c9f0a2a020e968fe396b1744737a83c07d1bb3404aaa432e14295a2b1cdc55afb0bbde6bda74d6971b34f89cde0b3effab3bba3030ee45b92836f060c0c3cd91e76e32b75725134c2bb680e33200ef9e1d7901992bad657af427094d50a66bb6324aeb67c0aaac06e2abe4010d5b20d95d87ccb71ddbc9de349736cd2ff22cd836e9546e48e2e3d46dafda8d7a9a8f3820fe723070b4f5ca7d6baea5f6e331e56e006de171c903d01595a07d11a0c287836b223f4ac0be4b039f8a676f03d3278be7188dfd4068b00000000042f5fcba96290bcfc3e23a301ddb759307c47404a759df133497cd535008fabd5e2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf97d24db2bfa41474bfb2f877d688fac5faa5e10a2808cf9de307370b93352e5486461524640eb36e98ed08cd7b6deb021e3f220b88100d283a1bb7286b7a1469e010000000200002088b3c0bc885588d6f1dc65c5643c9f1d3ef399fbffcd087618d97f00000000003d30eb76d0b3b2d808c86cc9ab37c6ec8c5f5d5af5d2e798ec94622a1225899e54b39c5affff7f20e8214e86"
	expectedMerkleRootReverse := "d61c6af278fbd938a1b192a9f19acff03cf2f9d310a4d37930751cd50ee37842"

	auxPowData, err := ParseAuxPowData(auxPowHex)
	if err != nil {
		t.Fatal(err)
	}

	auxHash, err := hex.DecodeString(auxHashHex)
	if err != nil {
		t.Fatal(err)
	}

	sideMask := auxPowData.blockchainBranch.sideMask

	var h hash.Byte32
	h.Assign(auxHash)
	h = h.Reverse()

	for i, branch := range auxPowData.blockchainBranch.branchs {
		isLeft := ((sideMask >> uint32(i)) & 1) == 0
		hNow := h.Hex()

		if isLeft {
			h = hash.JoinAndHash(h, branch)
			t.Logf("sha256(sha256(%s, %s)) = %s", hNow, branch.Hex(), h.Hex())
		} else {
			h = hash.JoinAndHash(branch, h)
			t.Logf("sha256(sha256(%s, %s)) = %s", branch.Hex(), hNow, h.Hex())
		}
	}

	t.Logf("merkle root: %s", h.Hex())
	t.Logf("merkle root reverse: %s", h.HexReverse())

	if h.HexReverse() != expectedMerkleRootReverse {
		t.Errorf("unexpected merkle root reverse, expected: %s, got: %s", expectedMerkleRootReverse, h.HexReverse())
	}
}
